use log::{error, info, warn};
use std::error::Error as StdError;
use std::fmt;
use tokio::signal::ctrl_c;
use tokio::signal::unix::{signal, SignalKind};
use tokio_i3ipc::event::{Event as I3Event, Subscribe, WindowChange};
use tokio_i3ipc::reply::Node;
use tokio_i3ipc::I3;

pub struct I3Manager {
    prev_window_id: Option<usize>,
    curr_window_id: Option<usize>,
    i3: I3,
}

impl I3Manager {
    pub async fn new() -> Result<I3Manager> {
        let i3 = I3::connect().await?;
        Ok(Self {
            prev_window_id: None,
            curr_window_id: None,
            i3,
        })
    }

    /** The main event loop

    Implementation notes:

    `i3-ipc` doesn't handle concurrency well as the message exchanges seem to be sequential.
    There's a pathologic when events are sent in between commands and their answers, eg:
    1. send focus command
    2. i3 updates focus and sends a `Window` type event
    3. i3 sends the response to the focus command

    The way `i3-ipc` implements `run_command` is with a `send_msg` immediately followed by
    `read_msg`. This breaks if an event is sent in the meantime, which can happen even as a result
    of the sent message (see above).

    To work around this, the following is done:
    1. Have a dedicated connection with i3 for events. No messaging happens over this.
    2. Have a dedicated connection with i3 for commands, not subscribed to anything, so no events.
    3. Have an event loop for sending commands to i3. This ensures that responses are consumed
        before sending new messages.
     */
    pub async fn run(&mut self) -> Result<()> {
        let mut i3_event_connection = I3::connect().await?;
        i3_event_connection.subscribe([Subscribe::Window]).await?;

        let mut usr1_stream = signal(SignalKind::user_defined1())?;

        loop {
            tokio::select! {
                i3_event = i3_event_connection.read_event() => {
                    match i3_event {
                        Ok(i3_event) => self.handle_i3_event(i3_event).await?,
                        Err(err) => error!("Got i3 error: {:#?}", err)
                    }
                }
                _ = ctrl_c() => {
                    info!("Received ^C, shutting down");
                    break;
                }
                _ = usr1_stream.recv() => {
                    self.switch_to_previous().await?;
                }
            }
        }

        Ok(())
    }

    async fn handle_i3_event(&mut self, event: I3Event) -> Result<()> {
        // Can't pattern match on a box in stable rust (june 2021)
        // https://doc.rust-lang.org/stable/unstable-book/language-features/box-patterns.html
        if let I3Event::Window(event) = event {
            if event.change == WindowChange::Focus {
                self.focus_changed(event.container).await?
            }
        }
        Ok(())
    }

    /// This function handles a focus change event generated by i3.
    /// The most important part is updating the internal state.
    async fn focus_changed(&mut self, new_node: Node) -> Result<()> {
        if self.curr_window_id.is_some() {
            self.prev_window_id = self.curr_window_id;
        }
        self.curr_window_id = Some(new_node.id);
        Ok(())
    }

    async fn switch_to_previous(&mut self) -> Result<()> {
        if let Some(prev_window_id) = self.prev_window_id {
            let payload = format!("[con_id={}] focus", prev_window_id);
            self.run_command(payload).await?;
        }
        Ok(())
    }

    async fn run_command<P: AsRef<str> + fmt::Display>(&mut self, payload: P) -> Result<()> {
        let resp = self.i3.run_command(&payload).await?;
        let resp: Vec<&String> = resp.iter().filter_map(|x| x.error.as_ref()).collect();
        if !resp.is_empty() {
            warn!(
                "I3 Command failed. Command: {} - Response: {:?}",
                &payload, resp
            );
        }
        Ok(())
    }
}

#[derive(Debug)]
pub enum Error {}

impl StdError for Error {}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        unimplemented!()
    }
}

impl From<tokio::io::Error> for Error {
    fn from(_: tokio::io::Error) -> Self {
        unimplemented!()
    }
}

pub type Result<T> = std::result::Result<T, Error>;
